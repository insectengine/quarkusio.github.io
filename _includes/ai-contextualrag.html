<div class="full-width-bg component">
  <div class="grid-wrapper">
    <div class="width-12-12 width-12-12-m">
      <h1>Contextual RAG (Multi-Sources, Rerank, Injection)</h1>
      <p>Advanced Contextual RAG extends the core frozen RAG pattern by incorporating multi-source retrieval, reranking, and content injection techniques. This is designed for more complex enterprise scenarios where information might be spread across various systems, requiring more sophisticated methods to ensure accuracy, relevance, and explainability. It allows for dynamic information handling, complex query processing, and provides clearer lineage for auditable decisions, making it ideal for high-stakes applications.</p>
      <h2>Main Use-Cases</h2>
      <ul>
        <li><strong>Complex Queries:</strong> Addresses intricate questions requiring synthesis from multiple sources.</li>
        <li><strong>Dynamic Information:</strong> Handles rapidly changing data environments by incorporating real-time updates.</li>
        <li><strong>High-Accuracy Needs:</strong> Reranking and injection ensure more precise and relevant answers.</li>
        <li><strong>Auditable Decisions:</strong> Provides clear lineage and context for generated responses, crucial for compliance and debugging.</li>
      </ul>
      <h2>Architecture Overview</h2>
      <p>The process begins with a User Query, which is first processed by a Query Transformer to refine or enhance it for more effective retrieval. The transformed query is then passed to a Query Router that decides which knowledge sources to target. For unstructured data, the ingestion pipeline remains the same as in the foundational RAG architecture (documents split, embedded, and stored in a vector store), but contextual RAG extends retrieval to multiple sources such as structured databases, APIs, and search indexes.</p>
      <p>The <strong>Query Router</strong> is responsible for directing the query to multiple retrieval sources simultaneously. These sources include:</p>
      <ul>
        <li><strong>Vector Retriever:</strong> Retrieves information based on semantic similarity from a vector store.</li>
        <li><strong>Web/Search Retriever:</strong> Gathers information from the web or external search engines.</li>
        <li><strong>Database Retriever:</strong> Extracts relevant data from structured databases.</li>
        <li><strong>Full-Text Retriever:</strong> Performs keyword-based searches across a corpus of documents.</li>
      </ul>
      <p>All the information retrieved from these diverse sources is then fed into an <strong>Aggregator/Reranker</strong>. This component combines and prioritizes the retrieved content based on relevance to the original query.</p>
      <p>The aggregated and reranked content is passed to a <strong>Content Injector (Prompt Builder)</strong>. This component constructs an Enhanced Prompt for the Large Language Model (LLM) by incorporating the retrieved context alongside the original user query.</p>
      <p>Finally, the LLM processes the <strong>Augmented Prompt</strong>, using the provided context to generate an answer. Alongside the answer, the system can return the retrieved source segments for transparency and verification, though these should be considered supporting context rather than strict citations.</p>
      <img class="light-only" src="{{site.baseurl}}/assets/images/ai/contextualrag-query.png" alt="Contextual RAG query image">
      <img class="dark-only" src="{{site.baseurl}}/assets/images/ai/contextualrag-query-dark.png" alt="Contextual RAG query image">
      <h2>Scalability & Performance</h2>
      <p>Efficiently scaling and optimizing the performance of your AI solutions are crucial for enterprise adoption and operational success. While this blueprint only gives you some high level guidance, we strongly recommend to also look into the non functional aspects of your solution and ways to address these concepts:</p>
      <ul>
        <li><strong>Domain/Tenant Sharding:</strong> Retrieves information based on semantic similarity from a vector store.</li>
        <li><strong>Caching:</strong> Cache query vectors and top-K hits for improved performance.</li>
        <li><strong>Asynchronous Ingestion:</strong> Utilize asynchronous ingestion to batch embeddings and stream deltas.</li>
        <li><strong>Lean Prompts:</strong> Prioritize token budget for context, keeping prompts concise.</li>
      </ul>
      <h2>Security</h2>
      <p>Architecting secure enterprise AI solutions demands a proactive approach to safeguard sensitive data and preserve organizational integrity. Below are some first thoughts about critical security considerations and architectural patterns you should further investigate when building your solution. </p>
      <ul>
        <li><strong>Authorization at retrieval:</strong> Before injecting context, filter by user/tenant claims.</li>
        <li><strong>Audit lineage:</strong> Store the chunk→document→source linkage with timestamps.</li>
        <li><strong>PII controls:</strong> Redact or mask sensitive spans before embedding and prompting.</li>
        <li><strong>Guard responses:</strong> Post-filter for data leakage and policy violations.</li>
      </ul>
    </div>
  </div>
</div>
