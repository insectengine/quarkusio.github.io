<div class="full-width-bg component">
  <div class="grid-wrapper">
    <div class="width-3-12 width-12-12-m">
      <img class="light-only" src="{{site.baseurl}}/assets/images/performance/icon-performance.svg" alt="Performance image">
      <img class="dark-only" src="{{site.baseurl}}/assets/images/performance/icon-performance-dark.svg" alt="Performance image">
    </div>
    <div class="width-9-12 width-12-12-m">
      <h2>The Quarkus Way</h2>
      <p>Quarkus redefines Java development by shifting most framework optimizations to the build phase. This approach minimizes runtime dependencies, maximizes dead code elimination, and introduces clear metadata contracts, resulting in leaner and more efficient applications.</p>
      <p>By performing these optimizations at build time, Quarkus ensures that the heavy lifting is done once, not at every startup, reducing memory usage and startup time.</p>
      <p>This approach benefits both GraalVM native images and traditional HotSpot JVM deployments, leading to faster, smaller, and more resource-efficient Java applications.</p>
    </div>
    <div class="width-3-12 width-12-12-m">
      <img class="light-only" src="{{site.baseurl}}/assets/images/performance/icon-memory.svg" alt="Performance image">
      <img class="dark-only" src="{{site.baseurl}}/assets/images/performance/icon-memory-dark.svg" alt="Performance image">
    </div>
    <div class="width-9-12 width-12-12-m">
      <h2>Reduced Memory</h2>
      <p>Quarkus reduces memory utilization for both traditional JVM deployments as well as native binaries using Ahead-of-Time (AOT) Compilation with GraalVM. It achieves this by leveraging build-time metadata processing, which shifts much of the runtime work to build time, lowering memory consumption during execution.</p>
    </div>
    <div class="width-3-12 width-12-12-m">
      <img class="light-only" src="{{site.baseurl}}/assets/images/performance/icon-startup.svg" alt="Performance image">
      <img class="dark-only" src="{{site.baseurl}}/assets/images/performance/icon-startup-dark.svg" alt="Performance image">
    </div>
    <div class="width-9-12 width-12-12-m">
      <h2>Fast Startup Time</h2>
      <p>Quarkus delivers fast startup times that allow for automatic scaling up and down of microservices on containers or Kubernetes deployments. It achieves fast startup times by performing build-time processing for both JVM and native binary deployments, reducing the work done during runtime. Quarkus precomputes metadata and optimizes class loading, significantly cutting down on initialization time. For natively compiled binaries, Quarkus uses GraalVM to eliminate startup overhead resulting in near-instant startup times by running directly as a native executable.</p>
    </div>
    <div class="width-3-12 width-12-12-m">
      <img class="light-only" src="{{site.baseurl}}/assets/images/performance/icon-diskspace.svg" alt="Performance image">
      <img class="dark-only" src="{{site.baseurl}}/assets/images/performance/icon-diskspace-dark.svg" alt="Performance image">
    </div>
    <div class="width-9-12 width-12-12-m">
      <h2>Disk Footprint</h2>
      <p>Quarkus reduces the footprint of Java applications by employing build-time processing to eliminate unnecessary runtime dependencies and by optimizing the applicationâ€™s deployment artifacts. It packages only the essential classes and resources needed at runtime, removing unused code through techniques like dead code elimination. When using GraalVM for native compilation, Quarkus further reduces the footprint by compiling the application into a compact native binary, stripping out the JVM and related dependencies.</p>
    </div>
  </div>
</div>

