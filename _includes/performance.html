<div class="full-width-bg component">
  <div class="grid-wrapper">
    <div class="width-3-12 width-12-12-m img-vert-center">
      <img class="light-only" src="{{site.baseurl}}/assets/images/performance/icon-performance.svg" alt="Performance icon">
      <img class="dark-only" src="{{site.baseurl}}/assets/images/performance/icon-performance-dark.svg" alt="Performance icon">
    </div>
    <div class="width-9-12 width-12-12-m">
      <h2>The Quarkus Way</h2>
      <p>Quarkus redefines Java development by shifting work to the build phase. This approach minimizes runtime dependencies, maximizes dead code elimination, and introduces clear metadata contracts, resulting in leaner and more efficient applications.</p>
      <p>The Quarkus approach helps to "strip out" all code which is only necessary to validate the user model</p>
      <ul>
        <li>compile classes or apply bytecode enhancements</li>
        <li>introspect in the model</li>
        <li>parse of framework configuration files</li>
        <li>discover extensions and services, or “apply auto-configuration"</li>
      </ul>
      <p>All that code is run only during the compilation phase; the classes don't even get loaded when  the app is started. This means the JIT can make much better optimisations, and spend less memory in doing so.</p>
      <p>By performing these optimizations at build time, Quarkus ensures that the heavy lifting is done once, not at every startup, reducing memory usage and startup time.</p>
      <p>This approach benefits both GraalVM native images and traditional HotSpot JVM deployments, leading to faster, smaller, and more resource-efficient Java applications.</p>
    </div>
    <div class="width-3-12 width-12-12-m img-vert-center">
      <img class="light-only" src="{{site.baseurl}}/assets/images/performance/icon-memory.svg" alt="Memory icon">
      <img class="dark-only" src="{{site.baseurl}}/assets/images/performance/icon-memory-dark.svg" alt="Memory icon">
    </div>
    <div class="width-9-12 width-12-12-m">
      <h2>Reduced Memory</h2>
      <p>Quarkus reduces memory utilization for both traditional JVM deployments as well as native binaries using Ahead-of-Time (AOT) Compilation with GraalVM. In a traditional architecture many classes are loaded into memory, only to be pruned out later. Quarkus is able to avoid this wasted classloading. Quarkus also leverages build-time metadata processing, lowering memory consumption during execution.</p>
    </div>
    <div class="width-3-12 width-12-12-m img-vert-center">
      <img class="light-only" src="{{site.baseurl}}/assets/images/performance/icon-startup.svg" alt="Startup icon">
      <img class="dark-only" src="{{site.baseurl}}/assets/images/performance/icon-startup-dark.svg" alt="Startup icon">
    </div>
    <div class="width-9-12 width-12-12-m">
      <h2>Fast Startup Time</h2>
      <p>Quarkus delivers fast startup times that allow for automatic scaling up and down of microservices on containers or Kubernetes deployments. It achieves fast startup times by performing build-time processing for both JVM and native binary deployments, reducing the work done during runtime. Quarkus precomputes metadata and optimizes class loading, significantly cutting down on initialization time. For example, some frameworks do “auto-wiring” to external dependencies by attempting to load many possible implementations, using Java Reflection APIs. Quarkus is able to pre-wire in the dependency and bypass this rather slow process.</p>
      <p> For natively compiled binaries, Quarkus uses GraalVM to eliminate startup overhead resulting in near-instant startup times by running directly as a native executable.</p>
    </div>
    <div class="width-3-12 width-12-12-m img-vert-center">
      <img class="light-only" src="{{site.baseurl}}/assets/images/performance/icon-throughput.svg" alt="Throughput icon">
      <img class="dark-only" src="{{site.baseurl}}/assets/images/performance/icon-throughput-dark.svg" alt="Throughput icon">
    </div>
    <div class="width-9-12 width-12-12-m">
      <h2>Higher Throughput</h2>
      <p>Doing more work upfront at build time doesn’t just improve memory footprint and startup times. It also makes normal program execution faster. How? The output of a Quarkus build process is JIT-friendly, which means the JIT can make better optimizations, and get the application to a super-optimized state faster. For example, because there’s less unused bytecode in a Quarkus application, the JIT can inline more effectively. Early elimination of unused classes also enables the JVM to use monomorphic method dispatching, instead of the much slower megamorphic method dispatching. Megamorphic dispatching is necessary when there are several implementations of the same interface present on the classpath.</p>
    </div>
    <div class="width-3-12 width-12-12-m img-vert-center">
      <img class="light-only" src="{{site.baseurl}}/assets/images/performance/icon-diskspace.svg" alt="Disk footprint icon">
      <img class="dark-only" src="{{site.baseurl}}/assets/images/performance/icon-diskspace-dark.svg" alt="Disk footprint icon">
    </div>
    <div class="width-9-12 width-12-12-m">
      <h2>Disk Footprint</h2>
      <p>Quarkus reduces the footprint of Java applications by employing build-time processing to eliminate unnecessary runtime dependencies and by optimizing the application’s deployment artifacts. It packages only the essential classes and resources needed at runtime, removing unused code through techniques like dead code elimination. When using GraalVM for native compilation, Quarkus further reduces the footprint by compiling the application into a compact native binary, stripping out the JVM and related dependencies.</p>
      <p>Traditionally, when optimizing software performance, there is often a tradeoff between throughput and memory footprint, or between startup time and eventual throughput. In contrast, many of the Quarkus optimizations, such as dead code elimination, improve multiple aspects of application performance.  The Quarkus way eliminates wasted work and results in a leaner application which both starts fast and runs fast, all while consuming less memory.</p>
    </div>
    <div class="width-12-12 width-12-12-m">
      <h2>Related Links</h2>
      <p><a href="https://quarkus.io/blog/reactive-crud-performance-case-study/">"Reactive CRUD Performance: A Case Study" Blog Post</a><br>
        <a href="https://quarkus.io/guides/performance-measure">"Measuring Performance" guide</a>
      </p>
    </div>
  </div>
</div>


